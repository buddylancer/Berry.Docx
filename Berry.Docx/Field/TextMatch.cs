using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using Berry.Docx.Documents;
using W = DocumentFormat.OpenXml.Wordprocessing;

namespace Berry.Docx.Field
{
    /// <summary>
    /// Represent a matched text that generated by the <see cref="Document.Find(Regex)"/> method.
    /// </summary>
    public class TextMatch
    {
        #region Private Member
        private readonly Paragraph _ownerParagraph;
        private readonly string _text;
        private readonly int _startCharPos;
        private readonly int _endCharPos;
        private List<TextRange> _ranges;
        #endregion

        #region Constructor
        /// <summary>
        /// Creates a new instance of the TextMatch class.
        /// </summary>
        /// <param name="ownerParagraph">The owner paragraph of the current matched text.</param>
        /// <param name="startCharPos">The zero-based position of start character of the matched text in the paragraph.</param>
        /// <param name="endCharPos">The zero-based position of end character of the matched text in the paragraph.</param>
        internal TextMatch(Paragraph ownerParagraph, int startCharPos, int endCharPos)
        {
            _ownerParagraph = ownerParagraph;
            _text = ownerParagraph.Text;
            _startCharPos = startCharPos;
            _endCharPos = endCharPos;
            _ranges = new List<TextRange>();
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets the matched text.
        /// </summary>
        public string Text => _text.Substring(_startCharPos, _endCharPos - _startCharPos + 1);
        #endregion

        #region Public Methods
        /// <summary>
        /// Make sure the matched text stay in a single TextRange that shall be returned. The owner paragraph structure could be changed.
        /// <para>The format of characters in the text will stay the same as the first character.</para>
        /// </summary>
        /// <returns>The TextRange that contains the matched text.</returns>
        public TextRange GetAsOneRange()
        {
            string text = string.Empty;
            int startPos = -1; // the position of the first character in the original TextRange
            int endPos = -1;  // the position of the last character in the original TextRange

            // Get all TextRanges that contain the matched text 
            IEnumerable<TextRange> ranges = _ownerParagraph.ChildObjects.OfType<TextRange>();
            for (int i = 0; i < ranges.Count(); i++)
            {
                TextRange tr = ranges.ElementAt(i);
                if(text.Length <= _startCharPos && (text+tr.Text).Length > _startCharPos)
                {
                    _ranges.Add(tr);
                    startPos = _startCharPos - text.Length;
                }
                if (text.Length > _startCharPos && (text + tr.Text).Length <= _endCharPos)
                {
                    _ranges.Add(tr);
                }
                if (text.Length <= _endCharPos && (text+tr.Text).Length > _endCharPos)
                {
                    if(!_ranges.Contains(tr))
                        _ranges.Add(tr);
                    endPos = _endCharPos - text.Length;
                }
                text += tr.Text;
            }

            // Move the matched text into a single TextRange
            if(_ranges.Count == 1)
            {
                TextRange tr = _ranges.First();
                if (startPos == 0)
                {
                    if(endPos == tr.Text.Length - 1)
                    {
                        return tr;
                    }
                    else
                    {
                        W.Run run = (W.Run)tr.XElement.CloneNode(true);
                        tr.XElement.InsertAfterSelf(run);
                        new TextRange(tr.Document, run).Text = tr.Text.Substring(endPos + 1);
                        tr.Text = tr.Text.Substring(startPos, endPos - startPos + 1);
                        return tr;
                    }
                }
                else
                {
                    if (endPos == tr.Text.Length - 1)
                    {
                        W.Run run = (W.Run)tr.XElement.CloneNode(true);
                        tr.XElement.InsertBeforeSelf(run);
                        new TextRange(tr.Document, run).Text = tr.Text.Substring(0, startPos);
                        tr.Text = tr.Text.Substring(startPos);
                        return tr;
                    }
                    else
                    {
                        W.Run run1 = (W.Run)tr.XElement.CloneNode(true);
                        W.Run run2 = (W.Run)tr.XElement.CloneNode(true);
                        tr.XElement.InsertBeforeSelf(run1);
                        tr.XElement.InsertAfterSelf(run2);
                        new TextRange(tr.Document, run1).Text = tr.Text.Substring(0, startPos);
                        new TextRange(tr.Document, run2).Text = tr.Text.Substring(endPos + 1);
                        tr.Text = tr.Text.Substring(startPos, endPos - startPos + 1);
                        return tr;
                    }
                }
            }
            else
            {
                int n = 0;
                foreach(TextRange tr in _ranges)
                {
                    if(n == 0)
                    {
                        if(startPos != 0)
                        {
                            W.Run run = (W.Run)tr.XElement.CloneNode(true);
                            tr.XElement.InsertBeforeSelf(run);
                            new TextRange(tr.Document, run).Text = tr.Text.Substring(0, startPos);
                        }
                        tr.Text = Text;
                    }
                    else if(n == _ranges.Count - 1 && endPos != tr.Text.Length - 1)
                    {
                        tr.Text = tr.Text.Substring(endPos + 1);
                    }
                    else
                    {
                        tr.Remove();
                    }
                    n++;
                }
                return _ranges.First();
            }
        }

        #endregion
    }
}
